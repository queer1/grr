#!/usr/bin/env python
"""Utils for flow related tasks."""

import fnmatch
import itertools
import os
import re

# Note that these function cannot be in utils
# because some of them rely on AFF4 which would
# create a cyclic dependency

import logging

from grr.lib import artifact_lib
from grr.lib import utils


# Grouping pattern: e.g. {test.exe,foo.doc,bar.txt}
GROUPING_PATTERN = re.compile("{([^}]+)}")


def GetUserInfo(client, user):
  """Get a User protobuf for a specific user.

  Args:
    client: A VFSGRRClient object.
    user: Username as string. May contain domain like DOMAIN\\user.
  Returns:
    A User rdfvalue or None
  """
  if "\\" in user:
    domain, user = user.split("\\", 1)
    users = [u for u in client.Get(client.Schema.USER, []) if u.username == user
             and u.domain == domain]
  else:
    users = [u for u in client.Get(client.Schema.USER, [])
             if u.username == user]

  if not users:
    return
  else:
    return users[0]


# TODO(user): Deprecate this function once Browser History is Artifacted.
def InterpolatePath(path, client, users=None, path_args=None, depth=0):
  """Take a string as a path on a client and interpolate with client data.

  Args:
    path: A single string/unicode to be interpolated.
    client: A VFSGRRClient object.
    users: A list of string usernames, or None.
    path_args: A dict of additional args to use in interpolation. These take
        precedence over any system provided variables.
    depth: A counter for recursion depth.

  Returns:
    A single string if users is None, otherwise a list of strings.
  """

  sys_formatters = {
      # TODO(user): Collect this during discovery from the registry.
      # HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\
      # Value: SystemRoot
      "systemroot": "c:\\Windows"
      }

  # Override any system formatters with path_args.
  if path_args:
    sys_formatters.update(path_args)

  if users:
    results = []
    for user in users:
      # Extract and interpolate user specific formatters.
      user = GetUserInfo(client, user)
      if user:
        formatters = dict((x.name, y) for x, y in user.ListFields())
        special_folders = dict(
            (x.name, y) for x, y in user.special_folders.ListFields())

        formatters.update(special_folders)
        formatters.update(sys_formatters)
        try:
          results.append(path.format(**formatters))
        except KeyError:
          pass   # We may be missing values for some users.
    return results
  else:
    try:
      path = path.format(**sys_formatters)
    except KeyError:
      logging.warn("Failed path interpolation on %s", path)
      return ""
    if "{" in path and depth < 10:
      path = InterpolatePath(path, client=client, users=users,
                             path_args=path_args, depth=depth+1)
    return path


def InterpolateClientAttributes(pattern, client=None, knowledge_base=None):
  """Interpolate all client attributes in pattern.

  Args:
    pattern: A string with potential interpolation markers. For example:
      "/home/%%Usernames%%/Downloads/"
    client: The client VFSGRRClient object we interpolate parameters from.
    knowledge_base: The knowledge_base to interpolate parameters from.

  Yields:
    All unique strings generated by expanding the pattern.

  We can interpolate from a knowledge base object (used in artifacts) or the raw
  Client object, but only one at a time.


  NOTE: This will eventually be replaced by the Artifact KnowledgeBase
        interpolator but we are maintaining it for now.
  """
  if client is None:
    attr_accessor = knowledge_base.get
  else:
    attr_accessor = lambda x: client.GetValuesForAttribute(x, only_one=True)

  components = []
  offset = 0
  for match in artifact_lib.INTERPOLATED_REGEX.finditer(pattern):
    components.append([pattern[offset:match.start()]])
    # Expand the attribute into the set of possibilities:
    alternatives = []

    # Only get the newest attribute that matches the pattern.
    for rdf_value in attr_accessor(match.group(1)):

    # Treat string as special because its an iterable :-(
      if isinstance(rdf_value, basestring):
        alternatives.append(rdf_value)
      else:
        for value in rdf_value:
          value = utils.SmartUnicode(value)
          if value:
            alternatives.append(value)

    components.append(set(alternatives))
    offset = match.end()

  components.append([pattern[offset:]])

  # Now calculate the cartesian products of all these sets to form all
  # strings.
  for vector in itertools.product(*components):
    yield "".join(vector)


def GlobPath(path):
  """Takes a path with possible globs and returns split components.

  For example:
  path = "/home/lib/*/foo/*.exe"

  returns: ['home/lib', '*', 'foo', '*.exe']

  Args:
    path: A string with shell globs.
  Returns:
    a list of path components.
  """
  components = []
  tmp = ""

  for path_component in path.split("/"):
    if artifact_lib.GLOB_MAGIC_CHECK.search(path_component):
      if tmp:
        components.append(tmp)

      tmp = ""
      components.append(fnmatch.translate(path_component))
    else:
      tmp = os.path.join(tmp, path_component)

  if tmp:
    components.append(tmp)

  return components


def InterpolateGrouping(pattern):
  """Interpolate inline globbing groups."""
  components = []
  offset = 0
  for match in GROUPING_PATTERN.finditer(pattern):
    components.append([pattern[offset:match.start()]])

    # Expand the attribute into the set of possibilities:
    alternatives = match.group(1).split(",")
    components.append(set(alternatives))
    offset = match.end()

  components.append([pattern[offset:]])
  # Now calculate the cartesian products of all these sets to form all strings.
  for vector in itertools.product(*components):
    yield u"".join(vector)
